{"version":3,"file":"secure-store.js","sourceRoot":"","sources":["../src/secure-store.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,gBAAgB,CAAA;AACtC,OAAO,EAAC,OAAO,IAAI,aAAa,EAAE,KAAK,EAAC,MAAM,aAAa,CAAA;AAC3D,OAAO,EAAC,KAAK,EAAC,MAAM,YAAY,CAAA;AAEhC;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,KAAK,CAAC,UAAkB;IAC5C,KAAK,CAAC,aAAa,CAAA,WAAW,UAAU,2BAA2B,CAAC,CAAA;IACpE,IAAI;QACF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,CAAA;QACrC,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,CAAC,CAAA;QAChF,OAAO,OAAO,CAAA;KACf;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,WAAW,CAAC,KAAK,EAAE,sCAAsC,CAAC,CAAA;KACjE;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,KAAK,CAAC,UAAkB,EAAE,OAAe;IAC7D,KAAK,CAAC,aAAa,CAAA,YAAY,UAAU,0CAA0C,CAAC,CAAA;IACpF,IAAI;QACF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,CAAA;QACrC,MAAM,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC,CAAA;KAClF;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,WAAW,CAAC,KAAK,EAAE,mCAAmC,CAAC,CAAA;KAC9D;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,MAAM,CAAC,UAAkB;IAC7C,KAAK,CAAC,aAAa,CAAA,YAAY,UAAU,2BAA2B,CAAC,CAAA;IACrE,IAAI;QACF,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,CAAA;QACrC,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,CAAC,CAAA;QAC1F,OAAO,MAAM,CAAA;KACd;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,WAAW,CAAC,KAAK,EAAE,wCAAwC,CAAC,CAAA;KACnE;AACH,CAAC;AAED,SAAS,WAAW,CAAC,KAAc,EAAE,OAAe;IAClD,IAAI,UAAU,GAAG,OAAO,CAAA;IACxB,IAAI,KAAK,GAAuB,EAAE,CAAA;IAClC,IAAI,KAAK,YAAY,KAAK,EAAE;QAC1B,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,KAAK,CAAC,OAAO,EAAE,CAAC,CAAA;QACjD,KAAK,GAAG,KAAK,CAAC,KAAK,CAAA;KACpB;IACD,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,CAAA;IACnC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAA;IACnB,OAAO,KAAK,CAAA;AACd,CAAC","sourcesContent":["import constants from './constants.js'\nimport {content as outputContent, debug} from './output.js'\nimport {Abort} from './error.js'\n\n/**\n * Fetches secured content from the system's keychain.\n * @param identifier {string} Identifier to identify the content.\n * @returns A promise that resolves with the content or null if it doesn't exist.\n */\nexport async function fetch(identifier: string): Promise<string | null> {\n  debug(outputContent`Reading ${identifier} from the secure store...`)\n  try {\n    const keytar = await import('keytar')\n    const content = await keytar.getPassword(constants.keychain.service, identifier)\n    return content\n  } catch (error) {\n    throw createAbort(error, 'Unable to read from the secure store')\n  }\n}\n\n/**\n * Securely stores the content under the given key.\n * @param identifier {string} Identifier to identify the content.\n * @param content {string} The content to be stored.\n * @returns A promise that resolves when the storing completes.\n */\nexport async function store(identifier: string, content: string): Promise<void> {\n  debug(outputContent`Updating ${identifier} in the secure store with new content...`)\n  try {\n    const keytar = await import('keytar')\n    await keytar.default.setPassword(constants.keychain.service, identifier, content)\n  } catch (error) {\n    throw createAbort(error, 'Unable to update the secure store')\n  }\n}\n\n/**\n * Removes the content with the given identifier.\n * @param identifier {string} Identifier to identify the content.\n * @returns A promise that resolves with true if the content was deleted.\n */\nexport async function remove(identifier: string): Promise<boolean> {\n  debug(outputContent`Removing ${identifier} from the secure store...`)\n  try {\n    const keytar = await import('keytar')\n    const result = await keytar.default.deletePassword(constants.keychain.service, identifier)\n    return result\n  } catch (error) {\n    throw createAbort(error, 'Unable to remove from the secure store')\n  }\n}\n\nfunction createAbort(error: unknown, message: string) {\n  let newMessage = message\n  let stack: string | undefined = ''\n  if (error instanceof Error) {\n    newMessage = message.concat(`: ${error.message}`)\n    stack = error.stack\n  }\n  const abort = new Abort(newMessage)\n  abort.stack = stack\n  return abort\n}\n"]}